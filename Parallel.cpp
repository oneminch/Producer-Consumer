#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstdio>

#include "BinarySearchTree.h"
using CSC1310::BinarySearchTree;
#include "BinaryTreeIterator.h"
using CSC1310::BinaryTreeIterator;
#include "ListArray.h"
using CSC1310::ListArray;
#include "ListArrayIterator.h"
using CSC1310::ListArrayIterator;

#include "Permutation.h"
using CSC1310::Permutation;
#include "Random.h"
using CSC1310::Random;

#include <pthread.h>
#include "CD.h"

#include <iostream>
using namespace std;

// for debugging error consistencies
// across producers and consumers
int P_PAR_ERR_COUNT = 0; // number of invalid trees generated by producer (parallel)
int C_PAR_ERR_COUNT = 0; // number of invalid trees received by consumer (parallel)
int P_SEQ_ERR_COUNT = 0; // number of invalid trees generated by producer (sequential)
int C_SEQ_ERR_COUNT = 0; // number of invalid trees received by consumer (sequential)

int BUFFER_SIZE = 100;
int NUM_PRODUCERS = 10;
int NUM_CONSUMERS = 10;
int NUM_TREES = 10000;
int ERROR_RATE = 10;

CD ***buffer;
int buffer_count = 0;
int producer_index = 0;
int consumer_index = 0;

int num_trees_p = 0;
int num_trees_c = 0;

pthread_cond_t empty, full;
pthread_mutex_t mutex;

void put(CD **cds_array)
{
	buffer[producer_index] = cds_array;
	producer_index = (producer_index + 1) % BUFFER_SIZE;
	buffer_count++; //buffer fills up
}

CD **get()
{
	CD **cds_array = buffer[consumer_index];
	consumer_index = (consumer_index + 1) % BUFFER_SIZE;
	buffer_count--; //buffer empties out
	return cds_array;
}

void deleteCDs(ListArray<CD> *list)
{
	ListArrayIterator<CD> *iter = list->iterator();

	while (iter->hasNext())
	{
		CD *cd = iter->next();
		delete cd;
	}

	delete iter;
}

bool is_bst_sorted(BinarySearchTree<CD> *bst)
{
	// verify that the items in a BST are in sorted order using an inorder traversal
	BinaryTreeIterator<CD> *bst_iter = bst->iterator();
	// bst_iter->setInorder(); // omitted
	CD *first = bst_iter->next();
	bool sorted = true;
	while (bst_iter->hasNext())
	{
		CD *second = bst_iter->next();
		if (CD::compare_items(first, second) >= 0)
		{
			sorted = false;
			break;
		}
		first = second;
	}
	delete bst_iter;

	return sorted;
}

CD **producer_seq(ListArray<CD> *cds, Random *rand)
{
	int num_items = cds->size();
	Permutation *p = new Permutation(num_items, num_items, rand);
	p->basicInit();
	CD **permute_cds = new CD *[num_items];
	int count = 0;
	while (p->hasNext())
	{
		int i = p->next();
		permute_cds[count] = cds->get(i);
		count++;
	}
	delete p;

	BinarySearchTree<CD> *bst = new BinarySearchTree<CD>(&CD::compare_items, &CD::compare_keys);
	for (int i = 0; i < num_items; i++)
	{
		CD *cd = permute_cds[i];
		bst->insert(cd);
	}
	delete[] permute_cds;

	// create a complete binary search tree
	BinarySearchTree<CD> *complete_bst = bst->minimizeComplete();
	CD **cds_array = new CD *[num_items];
	BinaryTreeIterator<CD> *complete_iter = complete_bst->iterator();

	// intentionally inserting an error
	int traversal_error = rand->getRandomInt(1, NUM_TREES);
	if (traversal_error >= ERROR_RATE)
	{
		complete_iter->setLevelorder();
	}
	else
	{
		// wrong traversal, consumer should detect a height error
		// still will be sorted, however
		P_SEQ_ERR_COUNT++;
		complete_iter->setPostorder();
	}
	count = 0;
	while (complete_iter->hasNext())
	{
		cds_array[count] = complete_iter->next();
		count++;
	}
	delete bst;
	delete complete_iter;
	delete complete_bst;

	return cds_array;
}

void consumer_seq(CD **cds_array, int num_items, int expected_height)
{
	BinarySearchTree<CD> *bst = new BinarySearchTree<CD>(&CD::compare_items, &CD::compare_keys);
	for (int i = 0; i < num_items; i++)
	{
		CD *cd = cds_array[i];
		bst->insert(cd);
	}

	BinaryTreeIterator<CD> *bst_iter = bst->iterator();
	CD *first = bst_iter->next();
	bool sorted = true;
	while (bst_iter->hasNext())
	{
		CD *second = bst_iter->next();
		if (CD::compare_items(first, second) >= 0)
		{
			sorted = false;
			break;
		}
		first = second;
	}
	delete bst_iter;

	int h = bst->getHeight();
	bool bal = bst->isBalanced();

	if (!sorted || h != expected_height || !bal)
	{
		C_SEQ_ERR_COUNT++;
		cout << "Sequential: Invalid Complete Binary Tree\n";
	}
	else
	{
		//cout << "valid complete binary tree" << endl;
	}

	delete bst;
	delete[] cds_array;
}

void *producer_par(void *args)
{
	// get producer argument values
	long *producer_args = (long *)args;
	ListArray<CD> *cds = (ListArray<CD> *)producer_args[0];
	Random *rand = (Random *)producer_args[1];

	while (num_trees_p < NUM_TREES)
	{
		// atomic: ensure exactly NUM_TREES amount of trees are created
		// and (apparently) no producer goes to sleep permanently
		pthread_mutex_lock(&mutex);
		if (num_trees_p < NUM_TREES)
		{
			num_trees_p += 1;
			pthread_mutex_unlock(&mutex);
		}
		else
		{
			// stop running any more loops
			pthread_mutex_unlock(&mutex);
			break;
		}

		// declare some variables
		int count = 0, num_items = cds->size();

		// create an array with the CDs in a random order
		Permutation *p = new Permutation(num_items, num_items, rand);
		p->basicInit();
		CD **permute_cds = new CD *[num_items];

		while (p->hasNext())
		{
			int i = p->next();
			permute_cds[count] = cds->get(i); // NOT consumer's get
			count++;
		}
		delete p;

		// create a BST
		BinarySearchTree<CD> *bst = new BinarySearchTree<CD>(&CD::compare_items, &CD::compare_keys);
		// insert the CDs in array order (different each time) into BST
		for (int i = 0; i < num_items; i++)
		{
			CD *cd = permute_cds[i];
			bst->insert(cd);
		}
		delete[] permute_cds;

		// create a complete binary search tree
		BinarySearchTree<CD> *complete_bst = bst->minimizeComplete();
		CD **cds_array = new CD *[num_items];
		BinaryTreeIterator<CD> *complete_iter = complete_bst->iterator();

		// place the CDs into an array using a level order traversal
		// and intentionally inserting an error based on error rate
		int traversal_error = rand->getRandomInt(1, NUM_TREES);
		if (traversal_error >= ERROR_RATE)
		{
			complete_iter->setLevelorder();
		}
		else
		{
			// wrong traversal, consumer should detect a height error
			// still will be sorted, however
			P_PAR_ERR_COUNT++;
			complete_iter->setPostorder();
		}

		count = 0;
		while (complete_iter->hasNext())
		{
			cds_array[count] = complete_iter->next();
			count++;
		}

		delete bst;
		delete complete_iter;
		delete complete_bst;

		// atomic: insert CD array into buffer
		pthread_mutex_lock(&mutex);

		while (buffer_count == BUFFER_SIZE)
		{
			// buffer is full
			pthread_cond_wait(&empty, &mutex);
		}

		// add the array that is supposed to represent a complete BT to buffer
		// signal consumers & unlock
		put(cds_array);
		pthread_cond_signal(&full);
		pthread_mutex_unlock(&mutex);
	}
}

void *consumer_par(void *args)
{
	// get consumer argument values
	int *consumer_args = (int *)args;
	int num_items = consumer_args[0];
	int exp_height = consumer_args[1];

	while (num_trees_c < NUM_TREES)
	{
		// atomic: ensure exactly NUM_TREES amount of trees are consumed
		// and (apparently) no consumer goes to sleep permanently
		pthread_mutex_lock(&mutex);
		if (num_trees_c < NUM_TREES)
		{
			num_trees_c += 1;
			pthread_mutex_unlock(&mutex);
		}
		else
		{
			// stop running any more loops
			pthread_mutex_unlock(&mutex);
			break;
		}

		// create a binary search tree
		// note: if the array represents a complete BT,
		// this process will create a complete BT that is also a BST
		BinarySearchTree<CD> *bst = new BinarySearchTree<CD>(&CD::compare_items, &CD::compare_keys);

		// atomic: get CD array from buffer and perform the checks
		pthread_mutex_lock(&mutex);

		while (buffer_count == 0)
		{
			// buffer is empty
			pthread_cond_wait(&full, &mutex);
		}

		// get array from buffer and items from that array
		// signal producers & unlock
		CD **cds_array = get();
		pthread_cond_signal(&empty);
		pthread_mutex_unlock(&mutex);

		// put the items from the array into a BST
		for (int j = 0; j < num_items; j++)
		{
			CD *cd = cds_array[j];
			bst->insert(cd);
		}

		// verify items are in sorted order
		// check that the BST is minimum height and balanced
		// the randomly determined errors will fail the height test
		int h = bst->getHeight();
		bool bal = bst->isBalanced();
		bool sorted = is_bst_sorted(bst);

		if (!sorted || h != exp_height || !bal)
		{
			C_PAR_ERR_COUNT++;
			cout << "Parallel: Invalid Complete Binary Tree\n";
		}
		// else {
		// 	cout << "Parallel: Valid Complete Binary Tree\n";
		// }
		delete bst;
		delete[] cds_array;
	}
}

int main()
{
	buffer = new CD **[BUFFER_SIZE];

	time_t par_start, par_end, seq_start, seq_end;
	Random *rand = Random::getRandom();

	// the unsorted ListArray of cds
	ListArray<CD> *cds = CD::readCDs("cds.txt");
	int num_items = cds->size();
	int expected_height = ceil(log2(num_items + 1));
	cout << "\nThe number of items in the file is: " << num_items;
	cout << "\nBased on the number of items, the min height should be: " << expected_height << endl;
	cout << endl;

	long *producer_args = new long[2];
	producer_args[0] = (long)cds;
	producer_args[1] = (long)rand;

	int *consumer_args = new int[2];
	consumer_args[0] = num_items;
	consumer_args[1] = expected_height;

	pthread_t producer_threads[NUM_PRODUCERS];
	pthread_t consumer_threads[NUM_CONSUMERS];

	// SEQUENTIAL SOLUTION: PROCESS ONE TREE AT A TIME
	seq_start = time(NULL);

	for (int i = 1; i <= NUM_TREES; i++)
	{
		CD **cd_array = producer_seq(cds, rand);
		consumer_seq(cd_array, num_items, expected_height);
	}

	seq_end = time(NULL);
	printf("Time (Sequential): %ds\n", (int)(seq_end - seq_start));

	cout << "\nInvalid Trees Created By Producer (Sequential): " << P_SEQ_ERR_COUNT;
	cout << "\nInvalid Trees Obtained By Consumer (Sequential): " << C_SEQ_ERR_COUNT << endl;
	cout << "\n----------------------------------------------------\n";

	// PARALLEL SOLUTION: USING THREADS
	par_start = time(NULL);

	if (NUM_CONSUMERS < 1 || NUM_PRODUCERS < 1)
	{
		cout << "Parallel: Invalid Number of Producers / Consumers.\n";
		return 0;
	}

	// create producers
	for (int i = 0; i < NUM_PRODUCERS; i++)
	{
		pthread_create(&producer_threads[i], NULL, &producer_par, (void *)producer_args);
	}
	// create consumers
	for (int i = 0; i < NUM_CONSUMERS; i++)
	{
		pthread_create(&consumer_threads[i], NULL, &consumer_par, (void *)consumer_args);
	}
	// join consumers
	for (int i = 0; i < NUM_CONSUMERS; i++)
	{
		pthread_join(consumer_threads[i], NULL);
	}
	// join producers
	for (int i = 0; i < NUM_PRODUCERS; i++)
	{
		pthread_join(producer_threads[i], NULL);
	}

	par_end = time(NULL);
	printf("Time (Parallel): %ds\n", (int)(par_end - par_start));

	cout << "\nInvalid Trees Created By Producer (Parallel): " << P_PAR_ERR_COUNT;
	cout << "\nInvalid Trees Obtained By Consumer (Parallel): " << C_PAR_ERR_COUNT << endl;

	delete[] producer_args;
	delete[] consumer_args;
	deleteCDs(cds);
	delete cds;

	return 0;
}
